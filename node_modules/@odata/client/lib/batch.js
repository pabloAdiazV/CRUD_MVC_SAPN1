"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseMultiPartContent = exports.parseResponse2 = exports.formatBatchRequest = exports.formatBatchRequestForOData401 = exports.formatHttpRequestString = void 0;
const concat_1 = __importDefault(require("@newdash/newdash/concat"));
const flatten_1 = __importDefault(require("@newdash/newdash/flatten"));
const join_1 = __importDefault(require("@newdash/newdash/join"));
const slice_1 = __importDefault(require("@newdash/newdash/slice"));
const startsWith_1 = __importDefault(require("@newdash/newdash/startsWith"));
const http_string_parser_1 = require("http-string-parser");
const uuid_1 = require("uuid");
const errors_1 = require("./errors");
const types_1 = require("./types");
const HTTP_EOL = "\r\n";
const formatHttpRequestString = (u, r) => {
    const parts = [];
    parts.push(`${r.method || "GET"} ${u} HTTP/1.1`);
    Object.entries(r.headers).forEach(([k, v]) => {
        parts.push(`${k}: ${v}`);
    });
    switch (typeof r.body) {
        case "string":
            parts.push(HTTP_EOL);
            parts.push(r.body);
            break;
        case "object":
            parts.push(HTTP_EOL);
            parts.push(JSON.stringify(r.body, types_1.ODataValueJSONReplacer));
            break;
        case "undefined":
            parts.push("");
        default:
            break;
    }
    return parts.join(HTTP_EOL);
};
exports.formatHttpRequestString = formatHttpRequestString;
/**
 *
 * format batch request in json format (in OData V4.01 Spec)
 *
 * ref: https://github.com/Soontao/light-odata/issues/29
 *
 * @experimental
 * @param requests
 */
const formatBatchRequestForOData401 = (requests = []) => {
    const rt = { requests: [] };
    requests.forEach((req, idx) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const tmpBatchRequestItem = {
            id: (_b = (_a = req.options) === null || _a === void 0 ? void 0 : _a.requestId) !== null && _b !== void 0 ? _b : idx.toString(),
            // @ts-ignore
            method: (_d = (_c = req.init) === null || _c === void 0 ? void 0 : _c.method) === null || _d === void 0 ? void 0 : _d.toLocaleLowerCase(),
            url: req.url
        };
        if ((_e = req.init) === null || _e === void 0 ? void 0 : _e.headers) {
            // @ts-ignore
            tmpBatchRequestItem.headers = (_f = req.init) === null || _f === void 0 ? void 0 : _f.headers;
        }
        // TODO: convert payload with `ODataValueJSONReplacer`
        if ((_g = req.init) === null || _g === void 0 ? void 0 : _g.body) {
            tmpBatchRequestItem.body = req.init.body;
        }
        if ((_h = req.options) === null || _h === void 0 ? void 0 : _h.atomicityGroup) {
            tmpBatchRequestItem.atomicityGroup = req.options.atomicityGroup;
        }
        if ((_j = req.options) === null || _j === void 0 ? void 0 : _j.dependsOn) {
            tmpBatchRequestItem.dependsOn = req.options.dependsOn;
        }
        rt.requests.push(tmpBatchRequestItem);
    });
    return rt;
};
exports.formatBatchRequestForOData401 = formatBatchRequestForOData401;
/**
 * format batch request string body
 *
 * @param requests
 * @param boundary a given boundary id
 */
const formatBatchRequest = (requests, boundary) => (0, join_1.default)((0, concat_1.default)(requests.map((r) => {
    if (r.init.method === "GET" || !r.init.method) {
        return (0, join_1.default)([
            `--${boundary}`,
            "Content-Type: application/http",
            `Content-Transfer-Encoding: binary`,
            "",
            (0, exports.formatHttpRequestString)(r.url, r.init),
            ""
        ], HTTP_EOL);
    }
    const generatedUuid = (0, uuid_1.v4)();
    return (0, join_1.default)([
        `--${boundary}`,
        `Content-Type: multipart/mixed; boundary=${generatedUuid}`,
        "",
        `--${generatedUuid}`,
        "Content-Type: application/http",
        `Content-Transfer-Encoding: binary`,
        "",
        (0, exports.formatHttpRequestString)(r.url, r.init),
        "",
        `--${generatedUuid}--`
    ], HTTP_EOL);
}), `--${boundary}--`), HTTP_EOL);
exports.formatBatchRequest = formatBatchRequest;
/**
 * parse stringify response in multipart
 */
const parseResponse2 = async (httpResponseString) => {
    const response = (0, http_string_parser_1.parseResponse)(httpResponseString);
    const rt = {
        json: async () => JSON.parse(response.body),
        text: async () => response.body,
        headers: response.headers,
        status: parseInt(response.statusCode, 10),
        statusText: response.statusMessage
    };
    return rt;
};
exports.parseResponse2 = parseResponse2;
const parseMultiPartContent = async (multipartBody, boundaryId) => {
    if (multipartBody && boundaryId) {
        // split
        const parts = multipartBody.split(`--${boundaryId}`);
        // remote head and tail parts
        const meaningfulParts = (0, slice_1.default)(parts, 1, parts.length - 1);
        return (0, flatten_1.default)(await Promise.all(meaningfulParts.map(async (p) => {
            const response = await (0, exports.parseResponse2)(p);
            const contentType = response.headers["Content-Type"];
            // recursive parse changeset response
            if ((0, startsWith_1.default)(contentType, "multipart/mixed")) {
                const innerBoundaryString = contentType.split("=").pop();
                return (0, exports.parseMultiPartContent)(await response.text(), innerBoundaryString);
            }
            else if (contentType === "application/http") {
                return (0, exports.parseResponse2)(await response.text());
            }
        })));
    }
    throw new errors_1.FrameworkError("parameter lost");
};
exports.parseMultiPartContent = parseMultiPartContent;
