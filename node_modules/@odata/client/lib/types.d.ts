import { RequestInit } from "node-fetch";
import { BatchRequest, ParsedResponse } from "./batch";
import { TokenRetrieveType } from "./oauth";
import { SystemQueryOptions } from "./params";
export type ODataVersion = "v2" | "v4";
export type HTTPMethod = "GET" | "HEAD" | "POST" | "PUT" | "DELETE" | "PATCH";
export type ODataVariant = "default" | "c4c" | "byd" | "cap" | "cpi" | "@odata/server" | "sap-gateway";
export declare const SAPNetweaverOData: Readonly<Array<ODataVariant>>;
export type FetchProxy = (url: string, init: RequestInit) => Promise<{
    /**
     * parsed body content
     */
    content: any;
    /**
     * original response object
     */
    response: Response;
}>;
export interface ODataNewOptionsOld {
    /**
     * metadata url
     *
     * @deprecated please try to use serviceEndpoint
     * @example `https://odata.org/V2/Northwind/Northwind.svc/$metadata`
     */
    metadataUri: string;
}
export interface ODataNewOptionsNew {
    /**
     *
     * odata service endpoint
     *
     * @example `https://odata.org/V2/Northwind/Northwind.svc/`
     */
    serviceEndpoint: string;
}
export interface ODataNewOptionsCommon {
    /**
     * credential configuration, basic/oauth (client credentials)
     */
    credential?: Credential;
    /**
     * fetch proxy of all request
     */
    fetchProxy?: FetchProxy;
    /**
     * auto process csrf token of c4c
     */
    processCsrfToken?: boolean;
    /**
     * common headers will be sent for each requests
     */
    commonHeaders?: {
        [headerName: string]: string;
    };
    /**
     * the header key of csrf token
     *
     * @default 'x-csrf-token'
     */
    csrfTokenName?: string;
    /**
     * service variant, some behaviors will be changed by this option
     */
    variant?: ODataVariant;
    /**
     * odata version
     *
     * @default 'v2'
     */
    version?: ODataVersion;
}
export type ODataNewOptions = (ODataNewOptionsNew | ODataNewOptionsOld) & ODataNewOptionsCommon;
export type ODataV4NewOptions = ODataNewOptions & {
    version: "v4";
};
export interface BatchRequestOptions<T> {
    /**
     * Collection Name
     */
    collection: string;
    /**
     * OData Entity ObjectID
     */
    id?: any;
    /**
     * OData system query options
     */
    params?: SystemQueryOptions;
    method?: HTTPMethod;
    /**
     * OData Entity Object
     */
    entity?: Partial<T>;
    /**
     * SAP OData need Content-Length but standard reject it
     */
    withContentLength?: boolean;
}
export interface ODataRequest {
    /**
     * the `entity set` name of data service
     */
    collection?: string;
    /**
     * GET for QUERY/READ; for QUERY, you can use params to control response data
     * PATCH for UPDATE
     * PUT for overrite
     * POST for CREATE
     * DELETE for delete
     */
    method?: HTTPMethod;
    params?: SystemQueryOptions;
}
export type ODataKeyPredicate = string | boolean | number | null | ODataValueObject | {
    [propertyKey: string]: ODataKeyPredicate;
};
export interface ODataReadIDRequest extends ODataRequest {
    id: ODataKeyPredicate; /** object key in READ/UPDATE/DELETE */
    params?: SystemQueryOptions;
}
export interface ODataQueryRequest extends ODataRequest {
    params?: SystemQueryOptions; /** params in QUERY */
}
export interface ODataWriteRequest<T> extends ODataRequest {
    entity?: Partial<T>; /** data object in CREATE/UPDATE */
    id?: ODataKeyPredicate;
    method: HTTPMethod;
}
export interface ODataActionRequest extends ODataRequest {
    actionName: string;
    payload?: any;
    id: ODataKeyPredicate;
}
export interface ODataFunctionRequest extends ODataRequest {
    functionName: string;
    payload?: any;
    id: ODataKeyPredicate;
}
export interface ODataActionImportRequest extends ODataRequest {
    actionName: string;
    parameters?: {
        [key: string]: any;
    };
}
export interface ODataFunctionImportRequest extends ODataRequest {
    functionName: string;
    parameters?: {
        [key: string]: any;
    };
}
export interface PlainODataResponse {
    error?: {
        code: string;
        message: {
            lang: string;
            value: string; /** server error message */
        };
    };
    d?: any;
}
export type BatchPlainODataResponse<E = any> = PlainODataResponse & {
    d?: {
        __count?: string; /** $inlinecount values */
        results?: Array<E>;
    } & E;
};
export type PlainODataSingleResponse<E = any> = {
    /**
     * @version 2.0.0
     */
    d?: {
        __count?: string; /** $inlinecount values */
    } & E;
} & PlainODataResponse;
export interface PlainODataMultiResponse<E = any> extends PlainODataResponse {
    d?: {
        __count?: string; /** $inlinecount values */
        results: Array<E>; /** result list/object */
    };
}
export interface Credential {
    /**
     * basic auth user name
     */
    username?: string;
    /**
     * basic password
     */
    password?: string;
    /**
     * oauth client id
     */
    clientId?: string;
    /**
     * oauth client secret
     */
    clientSecret?: string;
    /**
     * oauth token url
     */
    tokenUrl?: string;
    /**
     * oauth token retrieve type
     */
    tokenRetrieveType?: TokenRetrieveType;
    /**
     * traget scope
     */
    scope?: string;
}
/**
 * Same as Partial<T> but goes deeper and makes Partial<T> all its properties and sub-properties.
 */
export type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends Array<infer U> ? Array<DeepPartial<U>> : T[P] extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : DeepPartial<T[P]>;
};
/**
 * unwrap Promise Type
 */
export type UnwrapPromise<T> = T extends PromiseLike<infer U> ? U : T;
/**
 * unwrap batch request
 */
export type UnwrapBatchRequest<T> = T extends BatchRequest<infer U> ? U : T;
/**
 * unwrap batch request
 */
export type UnwrapParsedResponse<T> = T extends ParsedResponse<infer U> ? U : T;
export type BatchRequests = Array<Promise<BatchRequest>>;
export type BatchResponses<T> = Promise<{
    [K in keyof T]: ParsedResponse<UnwrapBatchRequest<UnwrapPromise<T[K]>>>;
}>;
/**
 * Edm value
 */
export declare abstract class ODataValueObject<T = any> {
    protected rawValue: T;
    protected constructor(rawValue: T);
    /**
     * to OData Uri string
     */
    abstract toString(): string;
    /**
     * to OData Json format value string
     *
     * @returns
     */
    toJSONString(): string;
}
export declare const ODataValueJSONReplacer: (key: any, value: any) => any;
/**
 * RawString
 */
export declare class RawString extends ODataValueObject<string> {
    static from(str: string): RawString;
    toString(): string;
}
export declare const RawValue: typeof RawString;
export declare abstract class ODataDateBase extends ODataValueObject {
    protected _uriEncoded: boolean;
    protected constructor(date: Date, uriEncoded?: boolean);
    toJSONString(): string;
}
/**
 * Edm.DateTime
 */
export declare class ODataDateTime extends ODataDateBase {
    /**
     *
     * @param date date object
     * @param uriEncoded encode date string with `encodeURIComponent`, default is `true`
     * @returns
     */
    static from(date: Date, uriEncoded?: boolean): ODataDateTime;
    toString(): string;
}
/**
 * Edm.DateTimeOffset
 */
export declare class ODataDateTimeOffset extends ODataDateBase {
    /**
     *
     * @param date date object
     * @param uriEncoded encode date string with `encodeURIComponent`, use it if you requires
     * @returns
     */
    static from(date: Date, uriEncoded?: boolean): ODataDateTimeOffset;
    toString(): string;
}
export declare class Guid extends RawValue {
}
export declare class EdmString extends ODataValueObject<string> {
    static from(str: string): EdmString;
    toString(): string;
    toJSONString(): string;
}
export declare const EdmV2: {
    DateTime: typeof ODataDateTime;
    DateTimeOffset: typeof ODataDateTimeOffset;
    RawString: typeof RawString;
    Guid: typeof Guid;
    String: typeof EdmString;
};
