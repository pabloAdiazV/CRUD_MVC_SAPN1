"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatId = exports.SearchParams = exports.GetAuthorizationPair = exports.FormatODataDateTimedate = exports.ConvertDateFromODataTime = void 0;
const base64_1 = require("./base64");
const errors_1 = require("./errors");
const types_1 = require("./types");
/**
 * ConvertDateFromODataTime (OData V2)
 *
 * @param dateString date string, format is /Date(1512691200000)/
 */
function ConvertDateFromODataTime(dateString) {
    if (dateString instanceof Date) {
        return dateString;
    }
    if (typeof dateString === "string") {
        // thanks https://github.com/Soontao/light-odata/pull/412#issuecomment-993708386
        const r1 = /\/Date\(([+|-]?\d+)\)\//g.exec(dateString);
        if (r1 !== null && r1[1] !== undefined) {
            return new Date(parseInt(r1[1]));
        }
    }
    throw new Error("date/datetime format is not correct");
}
exports.ConvertDateFromODataTime = ConvertDateFromODataTime;
/**
 * FormatODataDateTimedate (OData V2)
 *
 * format date to `/Date(1512691200000)/` format
 */
function FormatODataDateTimedate(date = new Date()) {
    return `/Date(${date.getTime()})/`;
}
exports.FormatODataDateTimedate = FormatODataDateTimedate;
function GetAuthorizationPair(user, password) {
    return { Authorization: `Basic ${(0, base64_1.encode)(`${user !== null && user !== void 0 ? user : ""}:${password !== null && password !== void 0 ? password : ""}`)}` };
}
exports.GetAuthorizationPair = GetAuthorizationPair;
class SearchParams {
    constructor() {
        this._store = new Map();
    }
    append(key, value) {
        this._store.set(key, value);
    }
    putAll(param) {
        if (param !== undefined && param instanceof SearchParams) {
            param._store.forEach((value, key) => {
                this._store.set(key, value);
            });
        }
    }
    toString() {
        return Array.from(this._store.entries()).map(([key, value]) => `${key}=${value}`).join("&");
    }
}
exports.SearchParams = SearchParams;
/**
 * convert the odata key predicate object/value to string
 *
 * @param key
 *
 * @example
 *
 * ```ts
 * formatId(1) // => String('(1)')
 * formatId({UUID:'xxx'}) // => String('(UUID='xxx')')
 * ```
 */
function formatId(key) {
    let rt = "";
    switch (typeof key) {
        // for compound key like
        // Alphabetical_list_of_products(CategoryName='Beverages',Discontinued=false,ProductID=1,ProductName='Chai')
        case "object":
            if (key instanceof types_1.ODataValueObject) {
                return `(${key.toString()})`;
            }
            // for plain object
            const compoundId = Object.entries(key).map((kv) => {
                const k = kv[0];
                const v = kv[1];
                switch (typeof v) {
                    case "string":
                        return `${k}='${v}'`;
                    case "number":
                        return `${k}=${v}`;
                    case "boolean":
                        return `${k}=${v}`;
                    default:
                        if (v === null) {
                            return `${k}=null`;
                        }
                        if (v instanceof types_1.ODataValueObject) {
                            return `${k}=${v.toString()}`;
                        }
                        // other type will be removed
                        return "";
                }
            }).filter((v) => v).join(",");
            rt = `(${compoundId})`;
            break;
        case "number":
            rt = `(${key})`;
            break;
        case "string":
            rt = `('${key}')`;
            break;
        case "undefined":
            break;
        default:
            throw new errors_1.FrameworkError(`Not supported ObjectID type ${typeof key} for request`);
    }
    return rt;
}
exports.formatId = formatId;
