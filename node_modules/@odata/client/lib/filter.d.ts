import { SystemQueryOptions } from "./params";
import { ODataValueObject } from "./types";
export type FilterValue = number | string | ODataValueObject | null | boolean | Symbol | object;
export declare enum ExprOperator {
    eq = "eq",
    ne = "ne",
    gt = "gt",
    lt = "lt",
    ge = "ge",
    le = "le"
}
type FieldExpr = {
    op: ExprOperator;
    value: FilterValue;
};
type FieldExprMappings = {
    [key: string]: FieldExpr[];
};
/**
 * odata property filter expression
 * @private
 * @internal
 */
declare class ODataPropertyExpr<T extends ODataFilter> {
    constructor(filter: T, fieldName: string, mapping: FieldExprMappings);
    private _filter;
    private _fieldName;
    private _exprMappings;
    private _getFieldExprs;
    private _addExpr;
    /**
     * equal
     * @param value
     */
    eq(value: FilterValue): T;
    /**
     * not equal
     * @param value
     */
    ne(value: FilterValue): T;
    /**
     * @deprecated use `filter.eq("value")` instead
     * @param value
     * @returns
     */
    eqString(value: string): T;
    /**
     * @deprecated use `filter.ne("value")` instead
     * @param value
     * @returns
     */
    neString(value: string): T;
    /**
     * greater or equal
     * @param value
     */
    ge(value: FilterValue): T;
    /**
     * greater than
     * @param value
     */
    gt(value: FilterValue): T;
    /**
     * less or equal
     * @param value
     */
    le(value: FilterValue): T;
    /**
     * less than
     * @param value
     */
    lt(value: FilterValue): T;
    /**
     * match any value in an array
     *
     * @param values
     */
    in(values?: FilterValue[]): T;
    /**
     * filter by value range
     *
     * @param low
     * @param max
     * @param includeBoundary
     */
    between(low: FilterValue, max: FilterValue, includeBoundary?: boolean): T;
    /**
     *
     * @deprecated please use filter.between(ODataDateTime.from(date), ODataDateTime.from(date))
     * @param start
     * @param end
     * @param includeBoundary
     * @returns
     */
    betweenDateTime(start?: Date, end?: Date, includeBoundary?: boolean): T;
    /**
     *  @deprecated please use filter.between(ODataDateTimeOffset.from(date), ODataDateTimeOffset.from(date))
     * @param start
     * @param end
     * @param includeBoundary
     * @returns
     */
    betweenDateTimeOffset(start?: Date, end?: Date, includeBoundary?: boolean): T;
}
/**
 * OData filter builder
 *
 */
export declare class ODataFilter<T = any> {
    static newBuilder<T = any>(): ODataFilter<T>;
    /**
     * construct a new filter
     */
    static newFilter<T = any>(): ODataFilter<T>;
    private _fieldExprMappings;
    /**
     * getExprMapping
     *
     * @internal
     * @private
     */
    private getExprMapping;
    /**
     * filter property
     * @see property
     * @param name field name or function expression
     */
    field(name: keyof T): ODataPropertyExpr<this>;
    /**
     * filter property
     *
     * @param name property name
     */
    property(name: keyof T): ODataPropertyExpr<this>;
    /**
     * The value of a field matches any value in the list.
     *
     * @deprecated please use filter.field().in()
     * @param name
     * @param values
     */
    fieldIn(name: keyof T, values: string[]): this;
    /**
     * The value of a field matches any value in the list.
     *
     * @deprecated please use filter.field().in()
     * @param name
     * @param values
     */
    fieldValueMatchArray(name: keyof T, values?: string[]): this;
    /**
     * DEPRECATED
     *
     * please use betweenDateTime/betweenDateTimeOffset
     *
     * @deprecated
     * @param name
     * @param start
     * @param end
     */
    inPeriod(name: keyof T, start: Date, end: Date): this;
    /**
     * @deprecated
     * @param name
     * @param start
     * @param end
     */
    betweenDateTime(name: keyof T, start: Date, end: Date): this;
    /**
     * @deprecated
     * @param name
     * @param start
     * @param end
     */
    betweenDateTimeOffset(name: keyof T, start: Date, end: Date): ODataFilter;
    /**
     * @deprecated
     * @param name
     * @param date
     */
    gtDateTime(name: keyof T, date: Date): this;
    /**
     * @deprecated
     * @param name
     * @param date
     */
    gtDateTimeOffset(name: keyof T, date: Date): this;
    /**
     * @deprecated
     * @param name
     * @param date
     */
    ltDateTime(name: keyof T, date: Date): this;
    /**
     * @deprecated
     * @param name
     * @param date
     */
    ltDateTimeOffset(name: keyof T, date: Date): this;
    /**
     * @deprecated c4codata will auto group exprs
     * @param filter
     */
    group(filter: ODataFilter): this;
    toString(): string;
    protected _buildFieldExprString(field: string): string;
    /**
     * build filter to string
     */
    build(): string;
}
export declare class ParamBoundedFilter<T = any> extends ODataFilter<T> {
    //#private;
    constructor(params: SystemQueryOptions);
    /**
     * the filter is ended, return the param object
     *
     * @returns the param
     */
    filterEnd(): SystemQueryOptions;
}
export declare function filter(): ODataFilter<any>;
export {};
