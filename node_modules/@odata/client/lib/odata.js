"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OData = void 0;
const Mutex_1 = require("@newdash/newdash/functional/Mutex");
const uuid_1 = require("uuid");
const batch_1 = require("./batch");
const entityset_1 = require("./entityset");
const errors_1 = require("./errors");
const filter_1 = require("./filter");
const oauth_1 = require("./oauth");
const params_1 = require("./params");
const tranformation_1 = require("./tranformation");
const types_1 = require("./types");
const util_1 = require("./util");
const request_1 = require("./request");
/**
 * OData Client
 */
class OData {
    static New(options) {
        var _a, _b, _c, _d;
        const rt = new OData((_a = options.serviceEndpoint) !== null && _a !== void 0 ? _a : options.metadataUri, options.credential, options.commonHeaders, options.fetchProxy, options.processCsrfToken);
        rt.version = (_b = options.version) !== null && _b !== void 0 ? _b : "v2";
        rt.variant = (_c = options.variant) !== null && _c !== void 0 ? _c : "default";
        // force process csrf token
        if (types_1.SAPNetweaverOData.includes(rt.variant)) {
            rt.processCsrfToken = true;
            // ref https://cxwiki.sap.com/pages/viewpage.action?pageId=511350333
            // use compatibility mode for c4c/byd
            rt.commonHeader["odata-v2-strict-json-format"] = "true";
        }
        rt.csrfTokenName = (_d = options.csrfTokenName) !== null && _d !== void 0 ? _d : request_1.S_X_CSRF_TOKEN;
        return rt;
    }
    /**
     * create odata client instance for odata v4
     *
     * @param options
     */
    static New4(options) {
        options.version = "v4";
        // @ts-ignore
        return OData.New(options);
    }
    /**
     * new odata query options
     *
     * @deprecated
     */
    static newParam() {
        return params_1.ODataParam.newParam();
    }
    /**
     * new odata query options
     */
    static newOptions() {
        return params_1.ODataParam.newOptions();
    }
    /**
     * new filter
     */
    static newFilter() {
        return filter_1.ODataFilter.newFilter();
    }
    /**
     * new transformation
     *
     * @returns
     */
    static newTransformation() {
        return tranformation_1.Transformation.newTransformation();
    }
    /**
     * OData
     *
     * @deprecated please use static method `OData.New` to create instance
     * @private
     */
    constructor(serviceEndpoint, credential, headers = {}, fetchProxy, 
    /**
     * auto fetch csrf token before broken operation
     */
    processCsrfToken = false) {
        /**
         * internal csrf token
         */
        this.csrfToken = "";
        /**
         * dont direct use this object
         *
         * use client.getHeaders()
         *
         */
        this.commonHeader = request_1.DEFULAT_HEADERS;
        this.fetchProxy = request_1.defaultProxy;
        this.processCsrfToken = false;
        this.csrfTokenName = request_1.S_X_CSRF_TOKEN;
        this.variant = "default";
        this.version = "v2";
        this.lock = new Mutex_1.Mutex();
        if (fetchProxy) {
            this.fetchProxy = fetchProxy;
        }
        if (serviceEndpoint === undefined) {
            throw new errors_1.ValidationError("metadata url required !");
        }
        if (serviceEndpoint.endsWith("$metadata")) {
            serviceEndpoint = serviceEndpoint.slice(0, serviceEndpoint.length - 9);
        }
        // e.g https://c4c-system/sap/c4c/odata/v1/c4codata/
        this.serviceEndpoint = serviceEndpoint;
        if (credential !== undefined) {
            this.credential = credential;
            if (credential.tokenUrl !== undefined &&
                credential.clientId !== undefined &&
                credential.clientSecret !== undefined) {
                this.oauthClient = new oauth_1.ClientCredentialsOAuthClient(credential.tokenUrl, credential.clientId, credential.clientSecret, credential.tokenRetrieveType, credential.scope);
            }
        }
        this.commonHeader = { ...this.commonHeader, ...headers };
        this.processCsrfToken = processCsrfToken;
    }
    /**
     * generate dynamic header
     */
    async getHeaders() {
        let rt = { ...this.commonHeader };
        if (this.credential) {
            if (this.credential.username !== undefined) {
                rt = {
                    ...rt,
                    ...(0, util_1.GetAuthorizationPair)(this.credential.username, this.credential.password)
                };
            }
            else if (this.oauthClient) {
                rt = {
                    ...rt,
                    ...(await this.oauthClient.getHeader())
                };
            }
        }
        if (this.processCsrfToken) {
            rt[this.csrfTokenName] = await this.getCsrfToken();
        }
        return rt;
    }
    /**
     * getEntitySet
     *
     * @param entitySetName the name of entity set, you can get it from metadata
     *
     */
    getEntitySet(entitySetName) {
        return new entityset_1.EntitySet(entitySetName, this);
    }
    /**
     * Set OData Client Http Basic credential
     *
     * @param credential
     */
    setCredential(credential) {
        this.credential = credential;
    }
    /**
     * setODataEndPath
     *
     * e.g. https://tenant.c4c.saphybriscloud.cn/sap/c4c/odata/v1/c4codata/
     */
    setODataEndPath(odataEndpoint) {
        if (odataEndpoint !== undefined) {
            this.serviceEndpoint = odataEndpoint;
            if (!this.serviceEndpoint.endsWith("/")) {
                this.serviceEndpoint += "/";
            }
        }
    }
    getVersion() {
        return this.version;
    }
    /**
     * fetch CSRF Token
     *
     * @param withCache set to `false` if you want to force to retrieve the refresh csrf token
     * @returns
     */
    async getCsrfToken(withCache = true) {
        return this.lock.use(async () => {
            var _a;
            if (withCache && this.csrfToken !== undefined && this.csrfToken !== null && ((_a = this.csrfToken) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                return this.csrfToken;
            }
            const config = {
                method: "GET",
                headers: { [this.csrfTokenName]: "fetch" }
            };
            if (this.credential) {
                config.headers = {
                    ...config.headers,
                    ...(0, util_1.GetAuthorizationPair)(this.credential.username, this.credential.password)
                };
            }
            const { response: { headers } } = await this.fetchProxy(this.serviceEndpoint, config);
            if (headers) {
                this.csrfToken = headers.get(this.csrfTokenName);
            }
            else {
                throw new errors_1.FrameworkError("csrf token need the odata proxy give out headers!");
            }
            return this.csrfToken;
        });
    }
    cleanCsrfToken() {
        if (this.csrfToken) {
            delete this.csrfToken;
        }
    }
    /**
     * odata request uri
     *
     * @param uri HTTP URI
     * @param systemOptions odata query params
     * @param method HTTP method
     * @param body request content
     */
    async requestUri(uri, systemOptions, method = "GET", body) {
        var _a, _b, _c, _d;
        const finalUri = uri;
        const config = { method, headers: await this.getHeaders() };
        // format body
        if (method !== "GET" && body) {
            if (typeof body !== "string") {
                config.body = JSON.stringify(body, types_1.ODataValueJSONReplacer);
            }
            else {
                config.body = body;
            }
        }
        // request & response
        let res = await this.fetchProxy(finalUri, config);
        // one time retry if csrf token time expired
        if (this.processCsrfToken === true) {
            if (((_d = (_c = (_b = (_a = res === null || res === void 0 ? void 0 : res.response) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b.get) === null || _c === void 0 ? void 0 : _c.call(_b, this.csrfTokenName)) === null || _d === void 0 ? void 0 : _d.toUpperCase()) === "Required".toUpperCase()) {
                config.headers[this.csrfTokenName] = await this.getCsrfToken(false); // force refresh
                res = await this.fetchProxy(finalUri, config);
            }
        }
        const { content } = res;
        return content;
    }
    /**
     * odata request
     *
     * @param collection CollectionName
     * @param id entity uuid or compound key
     * @param systemOptions query param, not work for single entity uri
     * @param method request method
     * @param entity odata Entity instance
     */
    async _executeDataOperation(collection, id, systemOptions, method = "GET", entity) {
        var _a;
        let url = `${this.serviceEndpoint}${collection}`;
        if (id) {
            url += this.formatIdString(id);
        }
        const query = (_a = systemOptions === null || systemOptions === void 0 ? void 0 : systemOptions.toString) === null || _a === void 0 ? void 0 : _a.call(systemOptions, this.version);
        if (query !== undefined && query.length > 0) {
            url = `${url}?${query}`;
        }
        return this.requestUri(url, systemOptions, method, entity);
    }
    async actionImport(actionName, parameters, params = this.newParam()) {
        return this.newRequest({
            method: "POST",
            params,
            parameters,
            actionName
        });
    }
    async functionImport(functionName, parameters, params = this.newParam()) {
        return await this.newRequest({
            parameters,
            params,
            method: "GET",
            functionName
        });
    }
    /**
     * convert the odata key predicate object/value to string
     *
     * @param key
     *
     * @example
     *
     * ```ts
     * this.formatIdString(1) // => String('(1)')
     * this.formatIdString({UUID:'xxx'}) // => String('(UUID='xxx')')
     * ```
     */
    formatIdString(key) {
        return (0, util_1.formatId)(key);
    }
    async newRequest(options) {
        if (options.actionName || options.functionName) {
            return this._executeActionOrFunction(options);
        }
        return this._executeDataOperation(options.collection, options.id, options.params, options.method, options.entity);
    }
    async _executeActionOrFunction(options) {
        var _a, _b, _c, _d, _e;
        let url = `${this.serviceEndpoint}`; // create new string
        let method = "GET";
        options.params = (_a = options.params) !== null && _a !== void 0 ? _a : this.newParam();
        /**
         * is bounded operation, means the operation maybe affected to a specific instance
         */
        const isBoundedOperation = ((options.collection !== undefined) && (options.id !== undefined));
        const actionName = options["actionName"];
        const functionName = options["functionName"];
        const isAction = (typeof actionName === "string");
        const isFunction = (typeof functionName === "string");
        if (isAction && isFunction) {
            throw new errors_1.ValidationError(`'actionName' and 'functionName' can not be fillled in same time.`);
        }
        if (!isAction && !isFunction) {
            throw new errors_1.ValidationError(`must provide 'actionName' or 'functionName'.`);
        }
        // if is bound operation, add the collection and key here
        if (isBoundedOperation) {
            url += `${options.collection}`;
            url += this.formatIdString(options.id);
        }
        if (!url.endsWith("/")) {
            url += "/";
        }
        if (isFunction) {
            url += `${functionName}`;
            method = "GET";
            switch (this.version) {
                case "v2":
                    if (options.parameters !== undefined) {
                        // convert function parameters to params custom params
                        options.params = (_b = options.params) !== null && _b !== void 0 ? _b : this.newParam();
                        Object
                            .entries(options.parameters)
                            .forEach(([key, value]) => {
                            options.params.custom(key, value);
                        });
                    }
                    break;
                case "v4":
                    if (options.parameters !== undefined) {
                        url += this.formatIdString(options.parameters);
                    }
                    else {
                        url += "()";
                    }
                    break;
                default:
                    break;
            }
        }
        if (isAction) {
            url += `${actionName}`;
            method = "POST";
        }
        // append query to uru
        const query = (_d = (_c = options === null || options === void 0 ? void 0 : options.params) === null || _c === void 0 ? void 0 : _c.toString) === null || _d === void 0 ? void 0 : _d.call(_c, this.version);
        if (query !== undefined && query.length > 0) {
            url += `?${query}`;
        }
        if (isAction) {
            // action with payload
            return this.requestUri(url, undefined, method, (_e = options.parameters) !== null && _e !== void 0 ? _e : {});
        }
        if (isFunction) {
            return this.requestUri(url, undefined, method);
        }
    }
    /**
     * format batch request parameter
     */
    async formatBatchRequests(requests) {
        const url = `${this.serviceEndpoint}$batch`;
        const req = {
            method: "POST",
            headers: await this.getHeaders()
        };
        // format promised requests
        const r = await Promise.all(requests.map(async (aBatchR) => await aBatchR));
        const requestBoundaryString = (0, uuid_1.v4)();
        req.headers["Content-Type"] = `multipart/mixed; boundary=${requestBoundaryString}`;
        req.body = (0, batch_1.formatBatchRequest)(r, requestBoundaryString);
        return { url, req };
    }
    /**
     * execute batch requests and get response
     *
     * @param requests batch request
     */
    async execBatchRequests(requests) {
        const { url, req } = await this.formatBatchRequests(requests);
        const { content, response: { headers } } = await this.fetchProxy(url, req);
        const responseBoundaryString = headers.get("Content-Type").split("=").pop();
        if (responseBoundaryString.length == 0) {
            // if boundary string empty, error here
        }
        // @ts-ignore
        return await (0, batch_1.parseMultiPartContent)(content, responseBoundaryString);
    }
    /**
     * execute batch requests in OData `V4.01` Json format, and get response
     *
     * this feature is experimental, use it on your own risk.
     *
     * @experimental
     * @param requests
     */
    async execBatchRequestsJson(requests) {
        // TODO: verify odata version here
        var _a;
        const reqs = await Promise.all(requests);
        const body = (0, batch_1.formatBatchRequestForOData401)(reqs);
        const url = `${this.serviceEndpoint}$batch`;
        const headers = await this.getHeaders();
        const response = await this.fetchProxy(url, { method: "POST", body: JSON.stringify(body), headers });
        const responseBody = response.content;
        if (responseBody["error"]) {
            throw new errors_1.ODataServerError(responseBody["error"]["message"] || "Unknown server error");
        }
        const rt = [];
        (_a = responseBody.responses) === null || _a === void 0 ? void 0 : _a.forEach((responseItem) => {
            rt.push({
                json: async () => responseItem.body,
                text: async () => JSON.stringify(responseItem.body),
                headers: responseItem.headers,
                status: responseItem.status,
                statusText: undefined,
                raw: responseItem
            });
        });
        // @ts-ignore
        return rt;
    }
    /**
     * create new filter
     *
     * @alias OData.newFilter
     */
    newFilter() {
        return OData.newFilter();
    }
    /**
     * create new system query options
     *
     * @deprecated
     * @alias OData.newParam
     */
    newParam() {
        return OData.newParam();
    }
    /**
     * create new system query options
     *
     * @returns
     */
    newOptions() {
        return OData.newOptions();
    }
    newTransformation() {
        return tranformation_1.Transformation.newTransformation();
    }
    async newBatchRequest(options) {
        let { withContentLength = false } = options;
        const { collection, method = "GET", id, params, entity } = options;
        if (types_1.SAPNetweaverOData.includes(this.variant)) {
            // for SAP NetWeaver Platform OData, need content length header
            withContentLength = true;
        }
        let url = collection;
        const headers = Object.assign({}, this.commonHeader); // clone
        const rt = { url, init: { method, headers, body: "" } };
        if (id) {
            url += this.formatIdString(id);
        }
        // READ OPERATION
        if (method === "GET" || method === "DELETE") {
            delete headers[request_1.S_CONTENT_TYPE];
            // other request don't need param
            if (params) {
                url = `${url}?${params.toString(this.version)}`;
            }
        }
        // WRITE OPERATION
        else {
            rt.init.body = entity;
            if (withContentLength) {
                rt.init.headers["Content-Length"] = encodeURI(rt.init.body.toString()).length;
            }
        }
        rt.init.headers = headers;
        rt.url = url;
        rt.options = options;
        return rt;
    }
}
exports.OData = OData;
