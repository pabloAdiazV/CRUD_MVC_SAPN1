"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ParamBoundedFilter_params;
Object.defineProperty(exports, "__esModule", { value: true });
exports.filter = exports.ParamBoundedFilter = exports.ODataFilter = exports.ExprOperator = void 0;
/* eslint-disable max-len */
const join_1 = require("@newdash/newdash/join");
const errors_1 = require("./errors");
const types_1 = require("./types");
var ExprOperator;
(function (ExprOperator) {
    ExprOperator["eq"] = "eq";
    ExprOperator["ne"] = "ne";
    ExprOperator["gt"] = "gt";
    ExprOperator["lt"] = "lt";
    ExprOperator["ge"] = "ge";
    ExprOperator["le"] = "le";
})(ExprOperator || (exports.ExprOperator = ExprOperator = {}));
/**
 * odata property filter expression
 * @private
 * @internal
 */
class ODataPropertyExpr {
    constructor(filter, fieldName, mapping) {
        this._exprMappings = mapping;
        this._fieldName = fieldName;
        this._filter = filter;
        // initilize
        if (this._getFieldExprs() == undefined) {
            this._exprMappings[this._fieldName] = [];
        }
    }
    _getFieldExprs() {
        return this._exprMappings[this._fieldName];
    }
    _addExpr(op, value) {
        var _a;
        switch (typeof value) {
            case "number":
            case "boolean":
                this._getFieldExprs().push({ op, value: `${value}` });
                break;
            case "string":
                if (value.startsWith("'") || value.startsWith("datetime")) {
                    this._getFieldExprs().push({ op, value });
                }
                else {
                    this._getFieldExprs().push({ op, value: `'${value}'` });
                }
                break;
            case "object":
                if (value instanceof types_1.ODataValueObject) {
                    this._getFieldExprs().push({ op, value: value.toString() });
                }
                else if (value === null) {
                    this._getFieldExprs().push({ op, value: null });
                }
                else {
                    throw new errors_1.FrameworkError(`Not support object ${((_a = value === null || value === void 0 ? void 0 : value["constructor"]) === null || _a === void 0 ? void 0 : _a["name"]) || typeof value} in odata filter eq/ne/gt/ge/ne/nt ...`);
                }
                break;
            case "undefined":
                throw new errors_1.ValidationError(`You must set value in odata filter eq/ne/gt/ge/ne/nt ...`);
            default:
                throw new errors_1.FrameworkError(`Not support typeof ${typeof value}: ${value} in odata filter eq/ne/gt/ge/ne/nt ...`);
        }
    }
    /**
     * equal
     * @param value
     */
    eq(value) {
        this._addExpr(ExprOperator.eq, value);
        return this._filter;
    }
    /**
     * not equal
     * @param value
     */
    ne(value) {
        this._addExpr(ExprOperator.ne, value);
        return this._filter;
    }
    /**
     * @deprecated use `filter.eq("value")` instead
     * @param value
     * @returns
     */
    eqString(value) {
        this._addExpr(ExprOperator.eq, `'${value}'`);
        return this._filter;
    }
    /**
     * @deprecated use `filter.ne("value")` instead
     * @param value
     * @returns
     */
    neString(value) {
        this._addExpr(ExprOperator.ne, `'${value}'`);
        return this._filter;
    }
    /**
     * greater or equal
     * @param value
     */
    ge(value) {
        this._addExpr(ExprOperator.ge, value);
        return this._filter;
    }
    /**
     * greater than
     * @param value
     */
    gt(value) {
        this._addExpr(ExprOperator.gt, value);
        return this._filter;
    }
    /**
     * less or equal
     * @param value
     */
    le(value) {
        this._addExpr(ExprOperator.le, value);
        return this._filter;
    }
    /**
     * less than
     * @param value
     */
    lt(value) {
        this._addExpr(ExprOperator.lt, value);
        return this._filter;
    }
    /**
     * match any value in an array
     *
     * @param values
     */
    in(values = []) {
        if (values.length > 0) {
            values.forEach((value) => {
                this.eq(value);
            });
        }
        return this._filter;
    }
    /**
     * filter by value range
     *
     * @param low
     * @param max
     * @param includeBoundary
     */
    between(low, max, includeBoundary = true) {
        if (low == undefined || max == undefined) {
            throw new errors_1.ValidationError("You must give out the start and end value");
        }
        if (includeBoundary) {
            this.ge(low);
            this.le(max);
        }
        else {
            this.gt(low);
            this.lt(max);
        }
        return this._filter;
    }
    /**
     *
     * @deprecated please use filter.between(ODataDateTime.from(date), ODataDateTime.from(date))
     * @param start
     * @param end
     * @param includeBoundary
     * @returns
     */
    betweenDateTime(start, end, includeBoundary = true) {
        if (start == undefined && end == undefined) {
            throw new errors_1.ValidationError("You must give out the start or end date");
        }
        if (start instanceof Date) {
            if (includeBoundary) {
                this.ge(types_1.ODataDateTime.from(start));
            }
            else {
                this.gt(types_1.ODataDateTime.from(start));
            }
        }
        if (end instanceof Date) {
            if (includeBoundary) {
                this.le(types_1.ODataDateTime.from(end));
            }
            else {
                this.lt(types_1.ODataDateTime.from(end));
            }
        }
        return this._filter;
    }
    /**
     *  @deprecated please use filter.between(ODataDateTimeOffset.from(date), ODataDateTimeOffset.from(date))
     * @param start
     * @param end
     * @param includeBoundary
     * @returns
     */
    betweenDateTimeOffset(start, end, includeBoundary = true) {
        if (start == undefined && end == undefined) {
            throw new errors_1.ValidationError("You must give out the start or end date");
        }
        if (start instanceof Date) {
            if (includeBoundary) {
                this.ge(types_1.ODataDateTimeOffset.from(start));
            }
            else {
                this.gt(types_1.ODataDateTimeOffset.from(start));
            }
        }
        if (end instanceof Date) {
            if (includeBoundary) {
                this.le(types_1.ODataDateTimeOffset.from(end));
            }
            else {
                this.lt(types_1.ODataDateTimeOffset.from(end));
            }
        }
        return this._filter;
    }
}
/**
 * OData filter builder
 *
 */
class ODataFilter {
    constructor() {
        this._fieldExprMappings = {};
    }
    static newBuilder() {
        return new ODataFilter();
    }
    /**
     * construct a new filter
     */
    static newFilter() {
        return new ODataFilter();
    }
    /**
     * getExprMapping
     *
     * @internal
     * @private
     */
    getExprMapping() {
        return this._fieldExprMappings;
    }
    /**
     * filter property
     * @see property
     * @param name field name or function expression
     */
    field(name) {
        return this.property(name);
    }
    /**
     * filter property
     *
     * @param name property name
     */
    property(name) {
        // @ts-ignore
        return new ODataPropertyExpr(this, name, this.getExprMapping());
    }
    /**
     * The value of a field matches any value in the list.
     *
     * @deprecated please use filter.field().in()
     * @param name
     * @param values
     */
    fieldIn(name, values) {
        // @ts-ignore
        return this.fieldValueMatchArray(name, values);
    }
    /**
     * The value of a field matches any value in the list.
     *
     * @deprecated please use filter.field().in()
     * @param name
     * @param values
     */
    fieldValueMatchArray(name, values = []) {
        if (values) {
            values.forEach((value) => {
                this.field(name).eqString(value);
            });
        }
        return this;
    }
    /**
     * DEPRECATED
     *
     * please use betweenDateTime/betweenDateTimeOffset
     *
     * @deprecated
     * @param name
     * @param start
     * @param end
     */
    inPeriod(name, start, end) {
        return this.betweenDateTime(name, start, end);
    }
    /**
     * @deprecated
     * @param name
     * @param start
     * @param end
     */
    betweenDateTime(name, start, end) {
        if (start && end) {
            return this.gtDateTime(name, start).ltDateTime(name, end);
        }
        throw new errors_1.ValidationError("You must give out the start and end date");
    }
    /**
     * @deprecated
     * @param name
     * @param start
     * @param end
     */
    betweenDateTimeOffset(name, start, end) {
        if (start && end) {
            return this.gtDateTimeOffset(name, start).ltDateTimeOffset(name, end);
        }
        throw new errors_1.ValidationError("You must give out the start and end date");
    }
    /**
     * @deprecated
     * @param name
     * @param date
     */
    gtDateTime(name, date) {
        return this.field(name).gt(types_1.ODataDateTime.from(date));
    }
    /**
     * @deprecated
     * @param name
     * @param date
     */
    gtDateTimeOffset(name, date) {
        return this.field(name).gt(types_1.ODataDateTimeOffset.from(date));
    }
    /**
     * @deprecated
     * @param name
     * @param date
     */
    ltDateTime(name, date) {
        return this.field(name).lt(types_1.ODataDateTime.from(date));
    }
    /**
     * @deprecated
     * @param name
     * @param date
     */
    ltDateTimeOffset(name, date) {
        return this.field(name).lt(types_1.ODataDateTimeOffset.from(date));
    }
    /**
     * @deprecated c4codata will auto group exprs
     * @param filter
     */
    group(filter) {
        this._fieldExprMappings = Object.assign(this._fieldExprMappings, filter.getExprMapping());
        return this;
    }
    toString() {
        return this.build();
    }
    _buildFieldExprString(field) {
        const exprs = this.getExprMapping()[field];
        if (exprs.length > 0) {
            if (exprs.filter((expr) => expr.op == ExprOperator.eq).length == 0) {
                return `(${(0, join_1.join)(exprs.map(({ op, value }) => `${field} ${op} ${value}`), " and ")})`;
            }
            return `(${(0, join_1.join)(exprs.map(({ op, value }) => `${field} ${op} ${value}`), " or ")})`;
        }
        return "";
    }
    /**
     * build filter to string
     */
    build() {
        let _rt = "";
        _rt = (0, join_1.join)(
        // join all fields exprs string
        Object.entries(this.getExprMapping()).map(([fieldName, exprs]) => {
            switch (exprs.length) {
                // if one field expr mapping array is empty
                case 0:
                    return "";
                // only have one expr
                case 1:
                    const { op, value } = exprs[0];
                    return `${fieldName} ${op} ${value}`;
                default:
                    // multi exprs
                    return this._buildFieldExprString(fieldName);
            }
        }), " and ");
        return _rt;
    }
}
exports.ODataFilter = ODataFilter;
class ParamBoundedFilter extends ODataFilter {
    constructor(params) {
        super();
        _ParamBoundedFilter_params.set(this, void 0);
        __classPrivateFieldSet(this, _ParamBoundedFilter_params, params, "f");
    }
    /**
     * the filter is ended, return the param object
     *
     * @returns the param
     */
    filterEnd() {
        return __classPrivateFieldGet(this, _ParamBoundedFilter_params, "f").filter(this);
    }
}
exports.ParamBoundedFilter = ParamBoundedFilter;
_ParamBoundedFilter_params = new WeakMap();
function filter() {
    return ODataFilter.newFilter();
}
exports.filter = filter;
