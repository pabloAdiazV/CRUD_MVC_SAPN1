"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.assignIn = void 0;
const createAssigner_1 = __importDefault(require("./.internal/createAssigner"));
const copyObject_1 = __importDefault(require("./.internal/copyObject"));
const keysIn_1 = __importDefault(require("./keysIn"));
/**
 * @private
 * @ignore
 */
const internal = (0, createAssigner_1.default)((object, source) => {
    (0, copyObject_1.default)(source, (0, keysIn_1.default)(source), object);
});
/**
 * This method is like `assign` except that it iterates over own and
 * inherited source properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @since 5.5.0
 * @alias extend
 * @category Object
 * @param target The destination object.
 * @param sources The source objects.
 * @returns Returns `object`.
 * @see [[assign]]
 * @example
 *
 * ```js
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * assignIn({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
 * ```
 */
function assignIn(target, ...args) {
    return internal(target, ...args);
}
exports.assignIn = assignIn;
exports.default = assignIn;
