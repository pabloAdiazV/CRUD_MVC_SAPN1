"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const SetCache_1 = __importDefault(require("./SetCache"));
const arrayIncludes_1 = __importDefault(require("./arrayIncludes"));
const arrayIncludesWith_1 = __importDefault(require("./arrayIncludesWith"));
const cacheHas_1 = __importDefault(require("./cacheHas"));
const createSet_1 = __importDefault(require("./createSet"));
const setToArray_1 = __importDefault(require("./setToArray"));
/** Used as the size to enable large array optimizations. */
const LARGE_ARRAY_SIZE = 200;
/**
 * The base implementation of `uniqBy`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
    let index = -1;
    let includes = arrayIncludes_1.default;
    let isCommon = true;
    const { length } = array;
    const result = [];
    let seen = result;
    if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith_1.default;
    }
    else if (length >= LARGE_ARRAY_SIZE) {
        const set = iteratee ? null : (0, createSet_1.default)(array);
        if (set) {
            return (0, setToArray_1.default)(set);
        }
        isCommon = false;
        includes = cacheHas_1.default;
        seen = new SetCache_1.default;
    }
    else {
        seen = iteratee ? [] : result;
    }
    outer: while (++index < length) {
        let value = array[index];
        const computed = iteratee ? iteratee(value) : value;
        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
            let seenIndex = seen.length;
            while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                    continue outer;
                }
            }
            if (iteratee) {
                seen.push(computed);
            }
            result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
                seen.push(computed);
            }
            result.push(value);
        }
    }
    return result;
}
exports.default = baseUniq;
