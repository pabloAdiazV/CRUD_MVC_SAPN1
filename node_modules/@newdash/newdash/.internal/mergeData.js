"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const composeArgs_1 = __importDefault(require("./composeArgs"));
const composeArgsRight_1 = __importDefault(require("./composeArgsRight"));
const CONSTANTS_1 = require("./CONSTANTS");
const replaceHolders_1 = __importDefault(require("./replaceHolders"));
/**
 * Merges the function metadata of `source` into `data`.
 *
 * Merging metadata reduces the number of wrappers used to invoke a function.
 * This is possible because methods like `bind`, `curry`, and `partial`
 * may be applied regardless of execution order. Methods like `ary` and
 * `rearg` modify function arguments, making the order in which they are
 * executed important, preventing the merging of metadata. However, we make
 * an exception for a safe combined case where curried functions have `ary`
 * and or `rearg` applied.
 *
 * @private
 * @ignore
 * @param {Array} data The destination metadata.
 * @param {Array} source The source metadata.
 * @returns {Array} Returns `data`.
 */
function mergeData(data, source) {
    var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (CONSTANTS_1.WRAP_BIND_FLAG | CONSTANTS_1.WRAP_BIND_KEY_FLAG | CONSTANTS_1.WRAP_ARY_FLAG);
    var isCombo = ((srcBitmask == CONSTANTS_1.WRAP_ARY_FLAG) && (bitmask == CONSTANTS_1.WRAP_CURRY_FLAG)) ||
        ((srcBitmask == CONSTANTS_1.WRAP_ARY_FLAG) && (bitmask == CONSTANTS_1.WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (CONSTANTS_1.WRAP_ARY_FLAG | CONSTANTS_1.WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == CONSTANTS_1.WRAP_CURRY_FLAG));
    // Exit early if metadata can't be merged.
    if (!(isCommon || isCombo)) {
        return data;
    }
    // Use source `thisArg` if available.
    if (srcBitmask & CONSTANTS_1.WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & CONSTANTS_1.WRAP_BIND_FLAG ? 0 : CONSTANTS_1.WRAP_CURRY_BOUND_FLAG;
    }
    // Compose partial arguments.
    var value = source[3];
    if (value) {
        var partials = data[3];
        data[3] = partials ? (0, composeArgs_1.default)(partials, value, source[4]) : value;
        data[4] = partials ? (0, replaceHolders_1.default)(data[3], CONSTANTS_1.PLACEHOLDER) : source[4];
    }
    // Compose partial right arguments.
    value = source[5];
    if (value) {
        partials = data[5];
        data[5] = partials ? (0, composeArgsRight_1.default)(partials, value, source[6]) : value;
        data[6] = partials ? (0, replaceHolders_1.default)(data[5], CONSTANTS_1.PLACEHOLDER) : source[6];
    }
    // Use source `argPos` if available.
    value = source[7];
    if (value) {
        data[7] = value;
    }
    // Use source `ary` if it's smaller.
    if (srcBitmask & CONSTANTS_1.WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : Math.min(data[8], source[8]);
    }
    // Use source `arity` if one is not provided.
    if (data[9] == null) {
        data[9] = source[9];
    }
    // Use source `func` and merge bitmasks.
    data[0] = source[0];
    data[1] = newBitmask;
    return data;
}
exports.default = mergeData;
