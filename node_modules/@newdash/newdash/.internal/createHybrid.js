"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const createCtor_1 = __importDefault(require("./createCtor"));
const replaceHolders_1 = __importDefault(require("./replaceHolders"));
const getHolder_1 = __importDefault(require("./getHolder"));
const reorder_1 = __importDefault(require("./reorder"));
const GLOBAL_1 = require("./GLOBAL");
const countHolders_1 = __importDefault(require("./countHolders"));
const createRecurry_1 = __importDefault(require("./createRecurry"));
const composeArgs_1 = __importDefault(require("./composeArgs"));
const composeArgsRight_1 = __importDefault(require("./composeArgsRight"));
const CONSTANTS_1 = require("./CONSTANTS");
/**
 * Creates a function that wraps `func` to invoke it with optional `this`
 * binding of `thisArg`, partial application, and currying.
 *
 * @private
 * @param {Function|string} func The function or method name to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to
 *  the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [partialsRight] The arguments to append to those provided
 *  to the new function.
 * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
    var isAry = bitmask & CONSTANTS_1.WRAP_ARY_FLAG, isBind = bitmask & CONSTANTS_1.WRAP_BIND_FLAG, isBindKey = bitmask & CONSTANTS_1.WRAP_BIND_KEY_FLAG, isCurried = bitmask & (CONSTANTS_1.WRAP_CURRY_FLAG | CONSTANTS_1.WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & CONSTANTS_1.WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined : (0, createCtor_1.default)(func);
    function wrapper() {
        var length = arguments.length, args = Array(length), index = length;
        while (index--) {
            args[index] = arguments[index];
        }
        if (isCurried) {
            var placeholder = (0, getHolder_1.default)(wrapper), holdersCount = (0, countHolders_1.default)(args, placeholder);
        }
        if (partials) {
            args = (0, composeArgs_1.default)(args, partials, holders, isCurried);
        }
        if (partialsRight) {
            args = (0, composeArgsRight_1.default)(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
            var newHolders = (0, replaceHolders_1.default)(args, placeholder);
            return (0, createRecurry_1.default)(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
        }
        var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
        length = args.length;
        if (argPos) {
            args = (0, reorder_1.default)(args, argPos);
        }
        else if (isFlip && length > 1) {
            args.reverse();
        }
        if (isAry && ary < length) {
            args.length = ary;
        }
        if (this && this !== GLOBAL_1.root && this instanceof wrapper) {
            fn = Ctor || (0, createCtor_1.default)(fn);
        }
        return fn.apply(thisBinding, args);
    }
    return wrapper;
}
exports.default = createHybrid;
