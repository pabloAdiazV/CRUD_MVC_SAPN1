"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reuse = void 0;
const assert_1 = require("../assert");
const functionWrapper_1 = require("../functional/functionWrapper");
const LRUMap_1 = __importDefault(require("../functional/LRUMap"));
const toHashCode_1 = __importDefault(require("../functional/toHashCode"));
/**
 * reuse values in specific duration for async functions
 *
 * @category Async
 * @since 5.22.0
 * @param runner must be an async function
 * @param duration default 1000 milliseconds
 * @param maxHandles different cache values for parameters
 * @returns
 */
function reuse(runner, duration = 1000, maxHandles = 1000) {
    (0, assert_1.mustProvideN)(runner, "runner", "async_function");
    (0, assert_1.mustProvide)(duration, "duration", "number");
    (0, assert_1.mustProvide)(maxHandles, "maxHandles", "number");
    return (0, functionWrapper_1.createFunctionWrapper)(runner, {
        global: {
            duration,
            handles: new LRUMap_1.default(maxHandles),
        },
        execute(ctx) {
            const { args, global: { handles } } = ctx;
            const key = (0, toHashCode_1.default)(args);
            if (handles.has(key)) {
                const { value, timeout } = ctx.global.handles.get(key);
                if (timeout >= Date.now()) {
                    return value;
                }
            }
            const v = ctx.runner(...ctx.args);
            handles.set(key, { value: v, timeout: Date.now() + duration });
            return v;
        },
    });
}
exports.reuse = reuse;
exports.default = reuse;
