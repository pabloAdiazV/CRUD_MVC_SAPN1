import { LRUMap } from "./functional/LRUMap";
import { TTLMap } from "./functional/TTLMap";
import { GeneralFunction } from "./types";
export interface CachePolicy {
    cacheUndefined?: boolean;
    cacheNull?: boolean;
    cacheThrow?: boolean;
}
export interface CacheConfig<T> {
    policy?: CachePolicy;
    params?: T;
}
export type LRUCacheConfig = CacheConfig<LRUCacheProviderParam>;
export type TTLCacheConfig = CacheConfig<TTLCacheProviderParam>;
export interface CacheProvider<K, V> extends Map<K, V> {
    /**
     * get cache or create it on necessary
     *
     * @param key
     * @param producer
     */
    getOrCreate<R>(key: K, producer: GeneralFunction<any[], R>): R;
}
/**
 * async cache provider
 */
export interface AsyncCacheProvider<K, V> extends CacheProvider<K, Promise<V>> {
}
export interface LRUCacheProviderParam {
    maxEntry: number;
}
/**
 * LRU Cache Provider
 *
 * @category Cache
 * @since 5.16.0
 */
export declare class LRUCacheProvider<K = any, V = any> extends LRUMap implements CacheProvider<K, V> {
    protected readonly _cachePolicy: CachePolicy;
    constructor(config: CacheConfig<LRUCacheProviderParam>);
    constructor(maxEntry?: number);
    getOrCreate<R>(key: K, producer: GeneralFunction<any[], R>): R;
}
export interface TTLCacheProviderParam {
    ttl?: number;
    checkInterval?: number;
    maxEntry?: number;
}
/**
 * TTL Cache Provider
 *
 * @since 5.16.0
 * @category Cache
 *
 */
export declare class TTLCacheProvider<K = any, V = any> extends TTLMap<K, V> implements CacheProvider<K, V> {
    protected readonly _cachePolicy: CachePolicy;
    constructor(config: CacheConfig<TTLCacheProviderParam>);
    constructor(ttl?: number, checkInterval?: number, maxEntry?: number);
    getOrCreate<R>(key: K, producer: GeneralFunction<any[], R>): R;
}
export declare const cacheProvider: {
    LRUCacheProvider: typeof LRUCacheProvider;
    TTLCacheProvider: typeof TTLCacheProvider;
};
