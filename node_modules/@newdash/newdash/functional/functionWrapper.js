"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFunctionWrapper = void 0;
/* eslint-disable max-len */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable prefer-arrow-callback */
const isAsyncFunction_1 = require("../isAsyncFunction");
const defineFunctionName_1 = require("./defineFunctionName");
/**
 * @internal
 * @private
 * @ignore
 * @param ctx
 * @returns
 */
const defaultExecute = (ctx) => ctx.runner(...ctx.args);
/**
 * @internal
 * @ignore
 * @private
 * @param ctx
 * @param result
 */
const returnSame = (ctx, result) => result;
/**
 * @internal
 * @ignore
 * @private
 */
const returnUndefined = (ctx) => undefined;
/**
 *
 * @internal
 * @ignore
 * @private
 */
const throwError = (ctx, err) => { throw err; };
/**
 *
 * create function wrapper for sync/async function
 *
 * @category Functional
 * @since 5.18.0
 * @param runner
 * @param options
 *
 */
function createFunctionWrapper(runner, options) {
    var _a, _b, _c, _d, _e, _f;
    /**
     * runner is async function or not
     */
    const isAsync = (0, isAsyncFunction_1.isAsyncFunction)(runner);
    // return runner direct if no logic
    if (options.before === undefined
        && options.error === undefined
        && options.execute === undefined
        && options.after === undefined) {
        return runner;
    }
    options.after = (_a = options === null || options === void 0 ? void 0 : options.after) !== null && _a !== void 0 ? _a : returnSame;
    options.before = (_b = options === null || options === void 0 ? void 0 : options.before) !== null && _b !== void 0 ? _b : returnUndefined;
    options.execute = (_c = options === null || options === void 0 ? void 0 : options.execute) !== null && _c !== void 0 ? _c : defaultExecute;
    // @ts-ignore
    options.global = (_d = options === null || options === void 0 ? void 0 : options.global) !== null && _d !== void 0 ? _d : {};
    options.error = (_e = options === null || options === void 0 ? void 0 : options.error) !== null && _e !== void 0 ? _e : throwError;
    const thisContext = (_f = options.thisContext) !== null && _f !== void 0 ? _f : this;
    const warpRunner = function (...args) {
        var _a;
        const ctx = {
            args,
            global: { ...((_a = options === null || options === void 0 ? void 0 : options.global) !== null && _a !== void 0 ? _a : {}) },
            runner,
            state: { isAsync },
            thisContext,
        };
        try {
            const earlyValue = options.before.call(thisContext, ctx);
            if (earlyValue !== undefined) {
                return earlyValue;
            }
            const rt = options.execute.call(thisContext, ctx);
            // if return promise
            // @ts-ignore
            if (rt instanceof Promise) {
                ctx.state.isAsync = true;
                return rt
                    .then((result) => options.after.call(thisContext, ctx, result)) // async result
                    .catch((error) => options.error.call(thisContext, ctx, error)); // async error
            }
            // else
            return options.after.call(thisContext, ctx, rt);
        }
        catch (error) {
            // sync error
            return options.error.call(thisContext, ctx, error);
        }
    };
    if (isAsync) {
        // if runner is async function, keep the warped function still an 'AsyncFunction'
        const asyncWarpRunner = async function (...args) {
            return warpRunner(...args);
        };
        Object.assign(asyncWarpRunner, { __wrap_global__: options.global });
        return (0, defineFunctionName_1.defineFunctionName)(asyncWarpRunner, runner === null || runner === void 0 ? void 0 : runner.name);
    }
    Object.assign(warpRunner, { __wrap_global__: options.global });
    return (0, defineFunctionName_1.defineFunctionName)(warpRunner, runner === null || runner === void 0 ? void 0 : runner.name);
}
exports.createFunctionWrapper = createFunctionWrapper;
