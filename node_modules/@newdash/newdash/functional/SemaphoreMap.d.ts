import { AsyncFunction } from "../types";
import Semaphore from "./Semaphore";
/**
 * high level SemaphoreMap
 *
 * @since 5.18.0
 * @category Functional
 */
export declare class SemaphoreMap {
    private _container;
    private _defaultSemCount;
    /**
     * SemaphoreMap, provision semaphore with giving key
     *
     * @param maximumSemObjects maximumSemObjects to avoid OOM, the default value is 1000000
     * @param defaultSemCount default sem permit number, the default value is 10
     */
    constructor(maximumSemObjects?: number, defaultSemCount?: number);
    /**
     * get semaphore or create a new one
     *
     * @param semaphoreKey
     * @param count
     */
    getOrCreate(semaphoreKey?: any, count?: number): Semaphore;
    /**
     * execute function with specify semaphore instance
     *
     * @param key the key of semaphore
     * @param runner async runner
     */
    execute<T>(key: any, runner: AsyncFunction<any[], T>): Promise<T>;
    /**
     * wrap a function with semaphore, the different parameter will use different semaphore instance
     *
     * simply, it could be used as a deeply 'limit' function,
     * after wrapping,
     * the function will be limited by parameter values (by specific semaphore total count)
     *
     * @param runner
     * @param runner params extractor, the return value will be used to determine the semaphore
     */
    wrap<P extends any[], T>(runner: AsyncFunction<P, T>, extractor?: (args: P) => any): AsyncFunction<P, T>;
    /**
     * static 'wrap' creator for function
     * @param maxSemNum
     * @param defaultSemCount
     * @param runner
     * @returns
     */
    static wrap<P extends any[], T>(maxSemNum: number, defaultSemCount: number, runner: AsyncFunction<P, T>): AsyncFunction<P, T>;
}
export default SemaphoreMap;
