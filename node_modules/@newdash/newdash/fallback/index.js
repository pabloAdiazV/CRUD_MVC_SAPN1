"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fallback = exports.recommend = void 0;
const cache_1 = require("./cache");
const circuit_1 = require("./circuit");
const retry_1 = require("./retry");
/**
 * recommend fallback policy
 *
 * `cache <- circuit <- retry <- runner`
 *
 * when error happened from `runner`, `retry` it firstly
 *
 * if `retry` finally failed, the `circuit breaker` will open,
 * later requests in a **duration** will not be executed, and just throw the `temp not available error`
 *
 * if the `circuit` is open, `cache` will catch the error, and try to get value from previous successful `cache`
 *
 * if there is no successful cache before, throw the original error (maybe wrapper with [[TemporaryUnAvailableError]]) directly
 *
 * @since 5.15.0
 * @category Fallback
 * @param runner
 */
function recommend(runner, options = {}) {
    return (0, cache_1.fallbackCache)((0, circuit_1.circuit)((0, retry_1.fallbackRetry)(runner, options.retryMaximumTime, options.retryInterval), options.circuitOpenDuration, options.cacheSize), options.cacheSize);
}
exports.recommend = recommend;
/**
 * fallback namespace
 *
 * @since 5.15.0
 */
exports.fallback = {
    cache: cache_1.fallbackCache,
    retry: retry_1.fallbackRetry,
    circuit: circuit_1.circuit,
    recommend
};
