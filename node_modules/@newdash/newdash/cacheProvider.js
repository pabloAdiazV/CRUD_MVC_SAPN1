"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cacheProvider = exports.TTLCacheProvider = exports.LRUCacheProvider = void 0;
const LRUMap_1 = require("./functional/LRUMap");
const TTLMap_1 = require("./functional/TTLMap");
const DEFAULT_CACHE_POLICY = {
    cacheUndefined: false,
    cacheNull: false,
    cacheThrow: false
};
class CachedThrowError {
    constructor(error) { this._error = error; }
    getError() { return this._error; }
}
function defaultGetOrCreate(cache, policy, key, producer) {
    if (!cache.has(key)) {
        try {
            const value = producer();
            // work with async function
            if (value instanceof Promise) {
                // @ts-ignore
                return value
                    .then((result) => {
                    if (result === null && !Boolean(policy.cacheNull) ||
                        result === undefined && !Boolean(policy.cacheUndefined)) {
                        // do nothing
                    }
                    else {
                        cache.set(key, result);
                    }
                    return result;
                })
                    .catch((error) => {
                    if (Boolean(policy.cacheThrow)) {
                        cache.set(key, new CachedThrowError(error));
                    }
                    throw error;
                });
            }
            if (value === null && !Boolean(policy.cacheNull) ||
                value === undefined && !Boolean(policy.cacheUndefined)) {
                // do nothing
            }
            else {
                cache.set(key, value);
            }
            return value;
        }
        catch (error) {
            if (Boolean(policy.cacheThrow)) {
                cache.set(key, new CachedThrowError(error));
            }
            throw error;
        }
    }
    const cachedValue = cache.get(key);
    if (cachedValue instanceof CachedThrowError) {
        throw cachedValue.getError();
    }
    return cachedValue;
}
/**
 * LRU Cache Provider
 *
 * @category Cache
 * @since 5.16.0
 */
class LRUCacheProvider extends LRUMap_1.LRUMap {
    constructor(param0) {
        var _a, _b, _c;
        super(typeof param0 === "number" ? param0 : ((_b = (_a = param0 === null || param0 === void 0 ? void 0 : param0.params) === null || _a === void 0 ? void 0 : _a.maxEntry) !== null && _b !== void 0 ? _b : 10240));
        this._cachePolicy = DEFAULT_CACHE_POLICY;
        if (typeof param0 === "object") {
            this._cachePolicy = Object.assign(DEFAULT_CACHE_POLICY, (_c = param0.policy) !== null && _c !== void 0 ? _c : {});
        }
    }
    getOrCreate(key, producer) {
        return defaultGetOrCreate(this, this._cachePolicy, key, producer);
    }
}
exports.LRUCacheProvider = LRUCacheProvider;
const DEFAULT_CACHE_PROVIDER_PARAM = {
    ttl: 30 * 1000,
    checkInterval: 60 * 1000,
    maxEntry: 10240
};
/**
 * TTL Cache Provider
 *
 * @since 5.16.0
 * @category Cache
 *
 */
class TTLCacheProvider extends TTLMap_1.TTLMap {
    constructor(...params) {
        const config = {
            policy: DEFAULT_CACHE_POLICY, params: DEFAULT_CACHE_PROVIDER_PARAM
        };
        if (typeof params[0] === "number") {
            config.params.ttl = params[0] || config.params.ttl;
            config.params.checkInterval = params[1] || config.params.checkInterval;
            config.params.maxEntry = params[2] || config.params.maxEntry;
        }
        else {
            config.policy = Object.assign(config.policy || {}, params[0].policy || {});
            config.params = Object.assign(config.params || {}, params[0].params || {});
        }
        super(config.params.ttl);
        this._cachePolicy = config.policy;
    }
    getOrCreate(key, producer) {
        return defaultGetOrCreate(this, this._cachePolicy, key, producer);
    }
}
exports.TTLCacheProvider = TTLCacheProvider;
exports.cacheProvider = {
    LRUCacheProvider,
    TTLCacheProvider
};
